<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fetch Skeleton Demo</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #f7f7f7;
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 32px;
    }
    .container {
      background: #fff;
      border-radius: 1em;
      box-shadow: 0 3px 20px rgba(0,0,0,0.08);
      padding: 2em 2em 1.5em 2em;
      max-width: 500px;
      width: 100%;
    }
    .posts-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 1.2em;
    }
    .post {
      border: 1px solid #e9ecef;
      background: #f9fafb;
      padding: 1em;
      border-radius: 0.5em;
      transition: background 0.2s;
    }
    .post-title {
      margin: 0 0 0.3em 0;
      font-size: 1.08em;
      font-weight: 600;
    }
    .post-body {
      margin: 0;
      color: #444;
      font-size: 0.97em;
      line-height: 1.5;
    }
    .skeleton {
      animation: shimmer 1.4s infinite linear;
      background: linear-gradient(90deg,#ececec 25%,#f3f3f3 50%,#ececec 75%);
      background-size: 400% 100%;
    }
    .skeleton-block {
      height: 1.1em;
      margin-bottom: 0.55em;
      border-radius: 0.25em;
    }
    .skeleton-title {
      width: 70%;
      height: 1.2em;
      margin-bottom: 0.6em;
      background: #ececec;
    }
    .skeleton-body {
      width: 92%;
      height: 0.95em;
      background: #ececec;
    }
    @keyframes shimmer {
      0% { background-position: -400% 0 }
      100% { background-position: 400% 0 }
    }
    .error {
      color: #c80032;
      background: #f9e5ea;
      border: 1px solid #c80032;
      padding: 1em;
      border-radius: 0.6em;
      margin-bottom: 1em;
      font-weight: 500;
    }
    .loading {
      color: #004c6d;
      background: #e7f3f8;
      border-radius: 0.6em;
      padding: 1em;
      font-weight: 500;
      margin-bottom: 1em;
    }
    .visually-hidden {
      border: 0 !important;
      clip: rect(1px,1px,1px,1px) !important;
      -webkit-clip-path: inset(50%) !important;
      clip-path: inset(50%) !important;
      height: 1px !important;
      margin: -1px !important;
      overflow: hidden !important;
      padding: 0 !important;
      position: absolute !important;
      width: 1px !important;
      white-space: nowrap !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2 id="feed-heading">Latest Posts</h2>
    <div id="status" aria-live="polite" role="status" class="loading">
      <span class="visually-hidden">Content loading...</span>
      <span aria-hidden="true">Loading posts...</span>
    </div>
    <ul id="posts-list" class="posts-list" aria-labelledby="feed-heading"></ul>
  </div>
  <script>
    // Utility to sanitize text for safe DOM insertion
    function setTextSafe(node, text) {
      node.textContent = text;
    }

    // Skeleton UI builder
    function showSkeleton(count) {
      const list = document.getElementById('posts-list');
      list.innerHTML = '';
      for (let i = 0; i < count; ++i) {
        const li = document.createElement('li');
        li.className = 'post';
        li.setAttribute('aria-hidden', 'true');
        // skeleton for title
        const title = document.createElement('div');
        title.className = 'skeleton skeleton-block skeleton-title';
        li.appendChild(title);
        // skeleton for body
        for (let j = 0; j < 2; ++j) {
          const bodyLine = document.createElement('div');
          bodyLine.className = 'skeleton skeleton-block skeleton-body';
          li.appendChild(bodyLine);
        }
        list.appendChild(li);
      }
    }

    function showLoading(visible) {
      const status = document.getElementById('status');
      status.style.display = visible ? '' : 'none';
      status.setAttribute('class', visible ? 'loading' : '');
      if (visible) {
        status.innerHTML =
          '<span class="visually-hidden">Content loading...</span>' +
          '<span aria-hidden="true">Loading posts...</span>';
      } else {
        status.textContent = '';
      }
    }

    function showError(message) {
      const status = document.getElementById('status');
      status.style.display = '';
      status.setAttribute('class', 'error');
      status.innerHTML =
        '<span class="visually-hidden">Error</span>' +
        '<span aria-hidden="true">' + (message || 'An unexpected error occurred.') + '</span>';
    }

    function renderPosts(posts) {
      const list = document.getElementById('posts-list');
      list.innerHTML = '';
      posts.forEach(post => {
        const li = document.createElement('li');
        li.className = 'post';

        // Safe insertion
        const title = document.createElement('h3');
        title.className = 'post-title';
        setTextSafe(title, post.title);

        const body = document.createElement('p');
        body.className = 'post-body';
        setTextSafe(body, post.body);

        li.append(title, body);
        list.appendChild(li);
      });
    }

    // Abortable fetch with timeout + error+state logic
    async function fetchPosts({ timeout = 6000, url = 'https://jsonplaceholder.typicode.com/posts?_limit=6', fetchImpl = fetch } = {}) {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), timeout);

      try {
        showLoading(true);
        showSkeleton(6);

        let response = await fetchImpl(url, { signal: controller.signal });
        if (!response.ok) throw new Error(`Failed to fetch (${response.status})`);
        let data = await response.json();

        showLoading(false);
        if (!Array.isArray(data)) throw new Error('Malformed response');
        renderPosts(data);
      } catch (err) {
        showLoading(false);
        if (err.name === 'AbortError') {
          showError('Request timed out. Try again later.');
        } else if (err instanceof TypeError) {
          showError('Network error. Please check your connection.');
        } else {
          showError(String(err && err.message ? err.message : err));
        }
        // Empty skeletons as well
        document.getElementById('posts-list').innerHTML = '';
      } finally {
        clearTimeout(t);
      }
    }

    // Initial fetch
    fetchPosts();

    // ----------- SIMPLE TEST CASES (Mocks & Manual) ------------

    // For automated test, you can call fetchPosts({fetchImpl: ...}) in console.

    // 1. Simulate SUCCESS:
    // Example: fetchPosts({ fetchImpl: (url, opt) => Promise.resolve({ ok: true, json: () => Promise.resolve([
    //   {title: "Test 1", body:"One"}, {title:"Test 2",body:"Two"}, {title:"Test 3",body:"Three"},
    //   {title:"Four",body:"4"},{title:"Five",body:"5"},{title:"Six",body:"6"}
    // ] ) }) });

    // 2. Simulate NETWORK ERROR:
    // Example: fetchPosts({ fetchImpl: (url, opt) => Promise.reject(new TypeError("Network down")) })

    // 3. Simulate SLOW/TIMEOUT:
    // Example:
    // fetchPosts({ timeout: 1000, fetchImpl: (url, opt) => new Promise(res => setTimeout(() => res({
    //   ok: true, json: () => Promise.resolve([
    //     {title: "Slow 1", body:"Body content 1"},{title: "Slow 2", body:"Body 2"},{title:"Slow 3",body:"Body 3"},
    //     {title:"4",body:"4"},{title:"5",body:"5"},{title:"6",body:"6"}
    //   ])
    // }), 3000)) });

    // Manual test:
    //   - Disconnect network: see error message and no skeletons.
    //   - Temporarily change URL to wrong endpoint.
    //   - Adjust timeout param for slow/successful test.
  </script>
</body>
</html>
